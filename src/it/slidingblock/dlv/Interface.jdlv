package it.slidingblock.dlv;
import java.util.*;
import it.slidingblock.core.*;
import it.slidingblock.core.block.*;
import java.awt.*;
public class Interface{
	public int dim,turno=1,key=0;
	public Interface(int dim)
	{
		this.dim=dim;
	}
	public ArrayList <Spostamenti> compute(World w){
		
		Point exitPoint=w.getMatrix().getExitCell();
		ExitCell exit=new ExitCell(exitPoint.x,exitPoint.y);
		Set<Blocco> blocchiDLV=new HashSet<Blocco>();
		Set<BKey> bKeyDLV=new HashSet<BKey>();
		ArrayList<Block> blocchiJ = w.getBlocks();
		ArrayList <Spostamenti> spostamenti=new ArrayList<Spostamenti>();		
		for (Block b: blocchiJ)
		{
			if (b instanceof KeyBlock)
				key=b.getId();
			Point bk=w.getMatrix().getFirstPoint(b.getId());
			bKeyDLV.add(new BKey(b.getId(),bk.y,bk.x,0));
			ArrayList<Point> temp=w.getMatrix().getPosition(b.getId());
			for (Point p:temp)
				blocchiDLV.add(new Blocco(b.getId(),p.x,p.y));
		}
		<#
			//input e output per java
			in=dim::dim,key::key,turno::turno,blocchiDLV::blocco,bKeyDLV::bKey,exit::uscita;
			out=spostamenti::sposta;
			///////////////////////INPUT/////////////////
			//composizione matrice
			row(X):-INTEGER_LITERAL(X),dim(T),X<T.
			col(X):-INTEGER_LITERAL(X),dim(T),X<T.
			cella(X,Y):-row(X),col(Y).
			//riempie per la prima volta i contiene
			piena(X,Y):-cella(X,Y),blocco(_,X,Y).
			contiene(B,X,Y,0):-cella(X,Y),blocco(B,X,Y).
			contiene(0,X,Y,0):-cella(X,Y),not piena(X,Y).	
			//adiacenze
			right(X,Y,X,Y1):-cella(X,Y),cella(X,Y1),Y1=Y+1.
			left(X,Y,X,Y1):-cella(X,Y),cella(X,Y1),Y1=Y-1.
			down(X,Y,X1,Y):-cella(X,Y),cella(X1,Y),X1=X+1.
			up(X,Y,X1,Y):-cella(X,Y),cella(X1,Y),X1=X-1.
			adiacente(X,Y,X1,Y1):-right(X1,Y1,X,Y).
			adiacente(X,Y,X1,Y1):-left(X1,Y1,X,Y).
			adiacente(X,Y,X1,Y1):-down(X1,Y1,X,Y).
			adiacente(X,Y,X1,Y1):-up(X1,Y1,X,Y).
			//si puo spostare se
			posSpostSu(B,B):-blocco(B,_,_).
			posSpostSu(B,0):-blocco(B,_,_).
			totBlockCol(B,T):-bKey(B,_,_,_),#count{G,X1,Y1:contiene(G,X1,Y1,0),G=B}=L,INTEGER_LITERAL(L),T=L-1.
			///////////////////////INPUT///////////////////
			////////////////////////////////////////////////////////////////GUESS//////////////////////////////////////////////////////////////////////
			//guess
			sposta(B,X,Y,X1,Y1,T1)|nonSposta(B,X,Y,X1,Y1,T1):-B>0,T1=T+1,bKey(B,X,Y,T),adiacente(X,Y,X1,Y1),contiene(G,X1,Y1,T),posSpostSu(B,G),turno(T1).
			spostatiIN(X,Y,T1):-sposta(_,_,_,X,Y,T1).
			spostatiDA(B,X,Y,T1):-sposta(B,X,Y,_,_,T1),not spostatiIN(X,Y,T1).
			//////////////////////////////////////////////////////GUESS////////////////////////////////////////////////////////
			////////////////////////////////////////ITERAZIONI/////////////////////////
			//aggiornamenti
			contiene(B,X,Y,T):-sposta(B,_,_,X,Y,T),turno(T).
			contiene(0,X,Y,T):-spostatiDA(B,X,Y,T),turno(T).
			contiene(B,X,Y,T1):-contiene(B,X,Y,T),T1=T+1,not spostatiDA(B,X,Y,T1),B>0,turno(T1).
			contiene(0,X,Y,T1):-contiene(0,X,Y,T),T1=T+1,not spostatiIN(X,Y,T1),turno(T1).
			sposta(B,X1,Y1,X2,Y2,T1):-sposta(B,X,Y,XX,YY,T1),up(X,Y,XX,YY),up(X1,Y1,X2,Y2),celCol(G,X,Y,X1,Y1,T),T=T1-1.
			sposta(B,X1,Y1,X2,Y2,T1):-sposta(B,X,Y,XX,YY,T1),down(X,Y,XX,YY),down(X1,Y1,X2,Y2),celCol(G,X,Y,X1,Y1,T),T=T1-1.
			sposta(B,X1,Y1,X2,Y2,T1):-sposta(B,X,Y,XX,YY,T1),right(X,Y,XX,YY),right(X1,Y1,X2,Y2),celCol(G,X,Y,X1,Y1,T),T=T1-1.
			sposta(B,X1,Y1,X2,Y2,T1):-sposta(B,X,Y,XX,YY,T1),left(X,Y,XX,YY),left(X1,Y1,X2,Y2),celCol(G,X,Y,X1,Y1,T),T=T1-1.
			bKey(B,X1,Y1,T1):-T1=T+1,bKey(B,X,Y,T),sposta(B,X,Y,X1,Y1,T1),turno(T1).
			bKey(BB,X,Y,T1):-T1=T+1,bKey(BB,X,Y,T),sposta(B,_,_,_,_,T1),BB!=B,turno(T1).
			celCol(B,X,Y,X1,Y,T):-bKey(B,X,Y,T),contiene(B,X1,Y,T),X1!=X.
			celCol(B,X,Y,X,Y1,T):-bKey(B,X,Y,T),contiene(B,X,Y1,T),Y1!=Y.
			celCol(B,X,Y,X1,Y1,T):-bKey(B,X,Y,T),contiene(B,X1,Y1,T),Y1!=Y,X1!=X.
			turno(T):-turno(T1),T=T1+1,key(K),uscita(N,M),contiene(G,N,M,T1),G!=K.
			///////////////////////////////////////////ITERAZIONI/////////////////////////
			///////////////////////////////////////////CONSTRAINTS////////////////////////
			//controllano se si possono spostare tutti i blocchi collegati al blocco piveaut
			:-bKey(B,X,Y,T),sposta(B,X,Y,XX,YY,T1),up(X,Y,XX,YY),#count{G,X1,Y1:G=B,up(X1,Y1,X2,Y2),celCol(G,X,Y,X1,Y1,T),contiene(F,X2,Y2,T),posSpostSu(G,F)}=L,INTEGER_LITERAL(L),totBlockCol(B,NUM),L!=NUM,T1=T+1.
			:-bKey(B,X,Y,T),sposta(B,X,Y,XX,YY,T1),down(X,Y,XX,YY),#count{G,X1,Y1:G=B,down(X1,Y1,X2,Y2),celCol(G,X,Y,X1,Y1,T),contiene(F,X2,Y2,T),posSpostSu(G,F)}=L,INTEGER_LITERAL(L),totBlockCol(B,NUM),L!=NUM,T1=T+1.
			:-bKey(B,X,Y,T),sposta(B,X,Y,XX,YY,T1),right(X,Y,XX,YY),#count{G,X1,Y1:G=B,right(X1,Y1,X2,Y2),celCol(G,X,Y,X1,Y1,T),contiene(F,X2,Y2,T),posSpostSu(G,F)}=L,INTEGER_LITERAL(L),totBlockCol(B,NUM),L!=NUM,T1=T+1.
			:-bKey(B,X,Y,T),sposta(B,X,Y,XX,YY,T1),left(X,Y,XX,YY),#count{G,X1,Y1:G=B,left(X1,Y1,X2,Y2),celCol(G,X,Y,X1,Y1,T),contiene(F,X2,Y2,T),posSpostSu(G,F)}=L,INTEGER_LITERAL(L),totBlockCol(B,NUM),L!=NUM,T1=T+1.
			// non e possibile che nella stessa cella ci siano piu blocchi
			:-contiene(B,X,Y,T),contiene(A,X,Y,T),B!=A.
			//non e possibile rimettere un blocco al punto di partenza
			:-sposta(B,X,Y,X1,Y1,T1),sposta(B,X1,Y1,X,Y,T),T=T1+1.
			// si muove un solo blocco per turno 
			:-sposta(B,_,_,_,_,T),sposta(B1,_,_,_,_,T),B1!=B.
			//non e possibile spostare se si e gia trovata la soluzione
			:-sposta(_,_,_,_,_,T1),uscita(N,M),key(K),contiene(G,N,M,T),G=K,T1=T+1.
			//non e possibile spostare in due direzioni diverse
			:-sposta(B,X,Y,X1,Y1,T),sposta(B,X,Y,X3,Y3,T),X3!=X1.
			:-sposta(B,X,Y,X1,Y1,T),sposta(B,X,Y,X3,Y3,T),Y3!=Y1.
			//non e possibile che non ci sia una volta il blocco chiave nella posizione duscita
			:- not #count{B,T:sposta(B,A,C,X,Y,T),key(B),uscita(X,Y)}=1.
			//meno numero spostamenti possibili
			:~turno(T).[T:1]
			///////////////////////////////////////////CONSTRAINTS////////////////////////
		#>
		.(" -N=7")if_no_answerset{System.out.println("No solution");}
		return spostamenti;
	}
}