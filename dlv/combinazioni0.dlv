#maxint=20.
% matrix
row(0..2). col(0..2). cella(X,Y):-col(X),row(Y).
% input facts
% blocks
blocco(1,1,1).blocco(2,1,1).blocco(3,1,1).blocco(4,1,1). blocco(6,1,1).
% key block
key(6).
% exit cell
exit(0,2).
% contiene (colonna,riga,blocco,turno).
contiene(0,0,1,0).contiene(0,1,2,0).contiene(1,1,3,0).contiene(1,0,4,0).contiene(2,0,6,0).
% Genera turni finché non vinci.
turno(1).
% adiacenza celle
% adiacente(c1.colonna,c1.riga,c2.colonna,c2.riga)
adiacente(X,Y,X,Y1) :- cella(X,Y),cella(X,Y1),Y1=Y+1.
adiacente(X,Y,X1,Y) :- cella(X,Y),cella(X1,Y),X1=X+1.
adiacente(X,Y,X1,Y1) :- adiacente(X1,Y1,X,Y).
% celle occupate
occupata(X,Y,T) :- contiene(X,Y,_,T).
% celle concesse per lo spostamento del blocco B
concesse(B,T,X,Y) :- contiene(X0,Y0,B,T),adiacente(X0,Y0,X,Y),not occupata(X,Y,T).

% Vittoria, quando il blocco chiave è contenuto nella cella d'uscita
vittoria(T) :- turno(T),contiene(X,Y,B,T),key(B),exit(X,Y).

sposta(B,T,X,Y) | nonsposta(B,T,X,Y) :- blocco(B,_,_),turno(T),concesse(B,T0,X,Y),T0=T-1.

spostato(B,T) :- sposta(B,T,_,_).
contiene(X,Y,B,T) :- sposta(B,T,X,Y).
contiene(X,Y,B,T) :- contiene(X,Y,B,T0),T=T0+1,not spostato(B,T).
turno(Tnext) :- sposta(_,T,_,_),Tnext=T+1,not vittoria(T).

:-contiene(X,Y,B,T),contiene(X,Y,B1,T),B1!=B.
:-sposta(B,T,_,_),sposta(B1,T,_,_),B1!=B.
:-sposta(B,T1,X,Y),sposta(B,T2,X,Y),T2=T1+1.
:-sposta(_,T,_,_),#count{X,Y:sposta(_,T,X,Y)}>1.
:-#count{V:vittoria(V)}=0.

:~sposta(_,T,_,_). [T:2]
:~sposta(B,T,_,_),B!=6. [1:1]
